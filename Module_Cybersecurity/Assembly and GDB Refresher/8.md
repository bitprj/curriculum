# Control Flow Hijacking

##### What is control flow hijacking?



##### Using Ghidra

Try using Ghidra to take a look at ‘6_control_flow_hijacking’. Your goal is to let the program reach the last “puts” statement with the help of gdb.

We’ve identified two roadblocks between us and the goal!

- That “sleep” function and the if(5<=7) comparison
- In GDB, you can modify the values of registers at any time!
- First, break right at the ‘call sleep’ instruction
  - Next, we can set the register ‘edi’ to 1, then continue running the program
  - We’ve just changed the parameter to ‘sleep’!
- That’s all good, but how are we gonna bypass the comparison?
- Break at the jle instruction
- Note that the jump won’t be taken (remember, “cmp $0x4,$0x7” calculates 7-4, which is >0!
- Change the instruction pointer to start executing as if you took the jump!

	- There’s a special $rip register, for “instruction pointer”. This holds the address of the next instruction that’s gonna be executed.

Therefore, if we “set $rip=0x(address to jump to)”, we can let the program run **whatever** we want!

That’s it! We successfully “tricked” the program into executing the final puts statement!

Of course, this is just a trick. In general, if you give a binary to someone they can do lots of analysis on it and run whatever code they want. This is why if you are making a service, never trust the clients, only trust the servers that are under your control. That was also a sneak peek into next week’s workshop. If an attacker can seize control of the $rip pointer, it’s game over! The trick is to find a way to control it… to be continued next time.