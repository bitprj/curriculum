# Exploiting a ret2libc Attack

- *Note: This is technically not a ret2libc attack since I linked libc statically to the binary. Close enough.

- Before you tackle a true ret2libc attack that requires a gadget, try 3_x86_ret2libc_static (source file is ret2libc.c)

- - This is a x86 binary with “system” inside. Try to call it with the right arguments!

- Now that you have an exploit working for 32bit, try 4_x64_ret2libc_static! (also compiled from ret2libc.c)

- - Other than adjusting offsets, the biggest thing you need to do is to find a gadget to put your argument in rdi. Good luck!

- Once you have your exploit ready, exploit twinpeaks.rkevin.dev port 30054 and grab the flag!

- If we have time or you want to explore more advanced usages of ret2libc, try 5_x64_ret2libc_harder_static!

- - You don’t have the findme variable anymore, so you’ll have to write your own on the stack, like last time’s 6_x86_bufov_args_harder!

  - - ASLR is disabled. For consistent results, run ./noaslr ./5_x64_ret2libc_harder_static

  - You don’t have the “system” function like before. You’ll have to find some other way to execute /bin/bash.

  - - I used the execve syscall. Hint: Look up how x86_64 syscalls work, and try to issue an execve syscall. For reference, my ropchain had 4 gadgets, not counting setting up some regions of memory.

  - It’s a lot, but if you have time to work through this you will gain a lot of understanding of how ROP and syscalls work! Service is at twinpeaks.rkevin.dev port 30055.

  - - And I might buy you dinner if you get the flag. *might*.

-  