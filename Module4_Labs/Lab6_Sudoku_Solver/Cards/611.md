<!--title={completing the Sudoku board: complete()}-->

<!--badges={Algorithmns:27}-->

<!--concepts{Functions}-->

# complete()
Step 1: Check the state of `moved`.

Within our while-loop as we're checking if there is available moves to be made in our `grid`, we can determine if the state of `moved` by assigning the result of `nextMove()` to it as such:

```python
	while hasMoves(grid) and moved:
		moved = nextMove(grid,True,depth,True)
```

`nextMove()` will return True if a move has been found (`moved` then equals True), or False if a move has not been found (`moved` then equals False). 

Step 2: return state of `hasMoved(grid)`.

After our while-loop has finished iterating (once either `hasMoves(grid)` or `moved` evaluates to False), then we will return the state of `hasMoves(grid)` as such:

```python
	return not hasMoves(grid)
```


If `hasMoves(grid) == True`, then `complete()` will return False because the `grid` has not been completed. Else if `hasMoves(grid) == False`, then `complete()` will return True since this indicates that the `grid` is complete. 

```python
def hasMoves(grid):
	return any(0 in row for row in grid)
```



The final function definition for `complete()` will look like this:

```python
def complete(grid,depth=0):
	moved = True
	while hasMoves(grid) and moved:
		moved = nextMove(grid,True,depth,True)
	return not hasMoves(grid)
```

