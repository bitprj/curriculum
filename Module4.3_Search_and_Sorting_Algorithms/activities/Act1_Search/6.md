<!--title={DFS in Python}-->

<!--badges={Algorithms:15, Python:5}-->

<!--concepts{Depth First Search}-->

**DFS Code Walkthrough**

Here is graphical representation of what an example graph looks like in "theory.":

<img src = "https://i.ibb.co/yd7qgvm/BFS-Code-Example.png" width = "450px">



***

After going through the DFS code, try to run the algorithm on this graph to test your understanding. We present the code to test running DFS on this graph at the end of the section.

Lets go through DFS implemented in Python in a step-by-step manner:

```python
from collections import defaultdict 
```

The first line here gets something called a "defaultdict" from the collections library. A "defaultdict" is basically a dictionary data structure, but instead of giving you an error when you try to access a key that doesn't exist, it makes it for you with a default value that you pass in. <sup> **1**</sup>

```python
class Graph: 

	def __init__(self): 		
		self.graph = defaultdict(list)
```

Here we initialize the graph class. What you need to know is simple: the __init__ function is called when a new graph object is made. When it is called, it just attaches defaultdict to the object. 

```python
	def addEdge(self,u,v): 
		self.graph[u].append(v)         
```

Now lets turn our attention to the `addEdge` function. What the following line basically means is: we create a function `addEdge`  that takes the starting node (`u`) and final node (`v`) and connects them via an edge in the graph. 

Programmatically, we store `u` as the key in a dictionary and store all its adjacent nodes in a list we can access through the said key . It stores this edge in the defaultdict (which is attached to the graph object we made) that we talked about earlier.

So, for example, if I wanted to create a graph with 3 nodes (node 1,2,3) which are connected by one edge from 1 to 2 and 1 to 3, it would look like this:

<img src="https://i.ibb.co/fnByb2Y/Connection-in-2-md-3.png" style="zoom:50%;" />

DFS faintly resembles BFS, but there are couple of distinctions. Lets take a look.

```python
	def DFS(self, v): 
		visited = [False] * (len(self.graph)) 
```

All this line does is set all of our nodes to "not visited" (`visited` keeps track of the vertices that have been visited). It just does it in fancy way. For example, [False,False,False] is equivalent to [False] * 3, where 3 is the number of edges in the graph.

```python
		self.DFSUtil(v, visited) 
```

DFS then calls a function called `DFSUtil`. `DFSUtil` is a recursive function that uses the function stack to save nodes for later use as we move along our DFS traversal. 

More specifically, this later use is when the DFS traversal finds out that there are no more adjacent, unvisited nodes on its current path. It will pop back to the newest added node and try to find new paths. This continues untill no nodes remain unvisited.

Lets take a look at `DFSUtil` in a more tangible way now.

```python
def DFSUtil(self, v, visited): 
	visited[v] = True
	print(v, end = ' ') 
```
We get a starting node called `v` and we mark it as True. The function also prints the node that we just visited as well. 

```python
		for i in self.graph[v]: 
			if visited[i] == False: 
				self.DFSUtil(i, visited) 
```

We then loop through all the adjacent vertices (`for i in self.graph[v]`). If the current vertex has not been visited, we call `DFSUtil` again! Remember that in recursive functions, the arguments are pushed onto a stack. So when we want to push the unvisited neighbor to the stack, we call the `DFSUtil` again, passing that neighbor as a parameter. That is, the stack that we need to run DFS is built-into the recursive function itself! 

Confusing, I know. BFS had an explicit queue and DFS uses the function stack. Try to run DFS on an example graph *by hand*, writing out the function stack for each recursive call. I'd recommend using the example graph given at the beginning of the section (starting at node 2) as we provide the answer code for DFS on that graph at the end of this section. 

Lets take a look at another illustrated example of running DFS:

![](https://i.ibb.co/pPT7X1d/Connection-in-2-md-4.png)

We start running DFS at node 1 and mark it as visited. We then push its unvisited neighbors (nodes 2 and 3) to the stack. We pop the last element pushed to the stack (node 3) and mark it as visited. Since node 3 has no unvisited neighbors, we do not add any of its neighbors to the stack. We then pop node 2 (the only element left on the stack) and mark it as visited. We have now traversed the entire tree!

This code is the code we use to test our DFS algorithm.  We initialize this graph with by writing :

```python
g = Graph() 
```

Furthermore, we add edges between nodes by the `addEdge()` function. The first argument is the node that we start the edge from and the second parameter is the node where we end the edge connection.

```python
g.addEdge(0, 1) 
g.addEdge(0, 2) 
g.addEdge(1, 2) 
g.addEdge(2, 0) 
g.addEdge(2, 3) 
g.addEdge(3, 3) 
```

The graph we are generating here is the same as that shown in the beginning section.

Finally, we initialize the DFS algorithm by specifying which node start the algorithm from.

```python
print ("Following is Depth First Traversal"
				" (starting from vertex 2)") 
g.DFS(2) 
```

Run this code and see the output to test your understanding of DFS. 

CongratsðŸŽ‰ for finishing this section of the lesson!

***

Sources/ Further Reading:

1) https://stackoverflow.com/questions/5900578/how-does-collections-defaultdict-work



